---
title: 数据结构及算法分析学习笔记
date: 2018-08-25 15:55:58
tags: 数据结构及算法
categories: 数据结构及算法
---

# 数据结构的基本概念
本篇内容旨在对数据结构的基本概念及术语进行介绍，并从全局的角度对数据结构有一个大体的认识。

## 数据结构的基本术语

### 数据的组成
**数据：**信息的载体，是描述客观事物属性的数、字符以及所有能输入到计算机中并被计算机程序识别和处理的符号的集合。

**数据项：**构成数据元素不可分割的最小单位。

**数据元素：**数据的基本单位，通常作为一个整体，一个个的数据元素就组成了数据（一个数据元素含有多个数据项）。

**数据对象：**数据的一个子集，它是同一类数据元素的集合。

例如，一个班级可以看作是数据对象，它由一个个学生组成，学生记录可以看作是一类数据元素，学生的学号、姓名、性别可以看成是数据项。

### 数据类型

**原子类型：**其值不可分割的数据类型；

**结构类型：**其值可以分成若干个结构类型或者原子类型的数据类型；

**抽象数据类型：**是指一个数学模型以及定义在模型上的一组操作，其定义仅仅取决于其逻辑特性，而与计算机的内部实现无关。


## 数据结构的组成
数据结构是相互之间存在一种或多种特定关系的数据元素的集合，其包括三个方面：逻辑结构、存储结构以及数据的运算。

**逻辑结构：**数据元素之间的逻辑关系，独立于计算机，跟数据存储无关。

**存储结构：**数据结构在计算机中的表示，包括数据元素的表示和关系的表示，存储结构是逻辑结构用计算机语言的实现，依赖于计算机语言。

**数据的运算：**运算的定义是针对逻辑结构的，指出了运算的功能；运算的实现是针对存储结构的，指出了运算的具体步骤。

### 逻辑结构
逻辑结构分为：线性结构和非线性结构。

**线性结构：**结构中的数据元素之间只存在一对一的关系，一般线性表、栈和队列、串和数据以及广义表都属于线性结构。

**非线性结构：**结构之中的数据元素之间存在一对多（树）或多对多（图）的关系，树和图属于非线性结构。

集合是一种特殊的逻辑结构，内部数据元素之间除了“同属于一个集合”外没有任何关系，可以被分为非线性结构之中。

### 存储结构
存储结构可以分为：顺序存储、链式存储、索引存储以及散列存储。

**顺序存储：**把逻辑上相邻的元素存储在物理上也相邻的存储单元中。特点是可以随机存取，每个元素占用的存储空间少；缺点是只能用相邻的整块存储单元，易产生外部碎片。

**链式存储：**逻辑上相邻的元素在物理上不一定相邻，借助存储地址进行访问。优点是不会产生外部碎片；缺点是元素因存储指针会占用额外空间，并且只能顺序存储。

**索引存储：**存储元素信息的同时还要建立附加的索引表（由一个个的索引项（形如 关键字，地址）组成）。优点是检索速度快；缺点是增加了索引表，占用额外空间，增删数据时要同时增删索引项。

**散列（Hash）存储：**通过元素的关键字计算出元素的存储地址。优点是查找、增加及删除元素都很快；缺点是散列函数不好会导致元素存储单元的冲突，事实上任何散列函数都会出现元素存储单元冲突的可能，而解决冲突会增加时间和空间开销。

## 算法的特性、要求及度量

算法是对特定问题求解步骤的一种描述

### 特性
算法的基本特性：有穷性、确定性、可行性、输入及输出。

### 要求
算法的要求（目标）：正确性、可读性、健壮性、效率（算法执行的时间）高、存储量（算法执行过程中所需要的最大存储空间）需求低。

### 度量
算法的度量分为：时间复杂性和空间复杂性。

**时间复杂性：**算法中所有语句的频度（一条语句在算法中被执行的次数）之和称为T(n)，被称为算法问题规模n的函数，时间复杂度即是分析T(n)的数量级。

由于在最深层循环的语句的频度与T(n)同数量级，所以一般通过最深层循环语句的频度f(n)（渐近时间复杂度,也就是该语句执行的次数）来表示时间复杂度。即 T(n) = O(f(n))，”O“为计算数量级。

算法的时间复杂度不仅依赖于问题的规模，也依赖于待输入元素的性质（比如输入元素的初始状态）。

一般以算法的最坏时间复杂度进行讨论。

**常见的渐近时间复杂度：O(1) < O(log2n) < O(n) < O(nlog2n) < O(n^2) < O(n^3) < O(2^n) < O(n!) < O(n^n)**

**空间复杂性：**算法所耗费的存储空间，也是算法问题规模的函数，记为O(g(n))；

上级程序除了需要存储空间存放本身执行指令、数据外，还需要辅助空间来实现计算及进行操作。

若是输入数据所占空间仅取决于问题本身，和算法无关，就只需要分析除输入和程序之外的额外空间即可。

**算法原地工作：**算法所需额外空间是常量，即O(1)。

## 算法时间复杂度计算方法
每次在设计算法的时候，我们都要考虑该算法的时间复杂度，从而可以从同一个问题的不同算法中取得相对时间复杂度较低的算法，那么时间复杂度到底如何计算，这就是本文的重点。

### 循环体中的变量和循环条件有关

此类时间复杂度计算只需要通过假设语句的执行次数，根据判断条件即可求出。

例1：
```C
int i = 1;
while(i < n) i *= 2;
```
i 在循环体中参与计算，但是同样又是while判断的依据，`i *= 2`这条语句的执行次数就是该算法的渐近时间复杂度，设该语句执行了t次，那么就是i在执行过程中乘了t个2，所以i的上限是2^t，所以最终判断条件是 2^t <= n,即t < log2n,这是渐近时间复杂度T(n) = O(log2n)。

例2：
```C
int y = 5;
while((y+1) * (y+1) < n) y = y+1;
```
`y = y+1`最终会执行t次，所以y值上限为`y = t + 5`，此时有判断条件`(t+6)^2 < n`，所以有`t < n^(1/2) - 6`，渐近时间复杂度T(n) = O(n^(1/2))。

### 循环体中的变量和循环条件无关

此类时间复杂度计算一般采用数学归纳法或者递推法，但又因算法执行的策略不同而有所不同，分为递归和非递归。

**1.递归算法**

对于递归算法，一般采用递推法（迭代法）进行时间复杂度计算。

例3：
**给出一个递归方程，当`n = 1,T(n) = 1`，当`n > 1,T(n) = 2T(n/2) + n`，其中n为问题的规模，n为2的整数次幂；某算法所需时间由该方程给出，求该算法的时间复杂度阶别。**

可以知道该题直接给出了时间复杂度的递推公式，所以设`n = 2^k`，则有`T(2^k) = 2T(2^(k-1)) + 2^k = (2^2)T(2^(k-2)) + 2 *(2^k) = (2^k)T(1) + k *(2^k) = (k + 1) * (2^k)`，即`T(n) = (log2n + 1) * n`，渐近时间复杂度为O(nlog2n)。



**2.非递归算法**

非递归算法的时间复杂度计算较为简单，直接累计最深层语句的执行次数就行。

例4：
```C
for(i=0;i<n;i++)
  for(j=0;j<m;j++)
    a[i][j] = 0;
```

时间复杂度T(n) = O(n*m)

未完待续。。。

## 小结

### 数据结构的组织逻辑图：

![数据结构](/images/DataStructure.jpg)


# 一般线性表
线性表是数据结构中最简单的逻辑结构，其特点为一对一，即**线性表中除表头和表位外的每个元素，都有且只有一个直接前驱和一个直接后继，而表头元素只有一个直接后继，没有直接前驱；表尾元素只有一个直接前驱，而无直接后继因此，表中各元素是由先后顺序的**。

注1：线性表中的各元素都属于同一数据类型，故而占用相同的存储空间，除此之外，线性表长度有限。

注2：本文对不同存储结构的算法实现都包括：线性表的创建、插入元素、删除元素、查找元素，在本篇中的查找算法使用的都是简单查找，其余查找算法将会由另外的一篇文章给出。

已经从逻辑结构上介绍了线性表的基本概念，也就是该结构中元素之间的相邻关系，接着就要讨论该如何实现该逻辑结构，这就引出了存储结构的概念。存储结构解决的是线性表在物理上如何存储的问题，线性表的存储结构决定了算法的实现方法，本文将要讨论的是线性表的顺序存储和链式存储。

## 顺序存储

### 基本概念

顺序存储又被称为顺序表，它利用一组地址连续的存储单元依次存储线性表中的数据元素，特点是**逻辑上相邻的数据元素在物理上也连续，所以顺序表中的元素可以通过首地址和元素序号进行随机访问，时间复杂度为`O(1)`，但是插入和删除操作都要移动大量元素**。

顺序表的存储结构可以用下图表示：
![数组指针](/images/arr_list.jpg)

### 静态顺序表

静态顺序表又可以被称为数组，数组的大小和空间在定义后就固定不变，这种内存分配方式被称为静态分配。

**静态顺序表的创建：**
```C
void InitList(SqList *L)
{
  L->length = 0;
  for(int i= 0;i < MAXSIZE;i++)
  {
    L->data[i] = (Elemtype)i;
    L->length++;
  }
  printf("length is %d\n",L->length);
}
```
**静态顺序表的插入：**
```C
bool ListInsert(SqList *L,int i,Elemtype e)
{
  if(i < 1 || i > L->length + 1) return false; //the scope of i needs to be suitable.
  if(L->length >= MAXSIZE) return false; //the length can't more than MAXSIZE.
  for(int j = L->length;j >= i;j--)
  {
    L->data[j] = L->data[j-1];
  }
  L->data[i-1] = e;
  L->length++;
  return true;
}
```
**静态顺序表的删除：**
```C
bool ListDelete(SqList *L,int i,Elemtype *e)
{
  if(i < 1 || i > L->length) return false; //the scope of i needs to be suitable.
  if(L->length <= 0) return false; //the length can't less than one.
  *e = L->data[i-1];
  for(int j = i;j < L->length;j++)
  {
    L->data[j-1] = L->data[j];
  }
  L->length--;
  return true;
}
```
**静态顺序表的查找：**
```C
//search the item appears in L for the first time.
int ListSearch(SqList *L,Elemtype e)
{
  for(int i = 0;i < L->length;i++)
  {
    if(L->data[i] == e) return (i+1);
  }
  return false;
}
```

静态顺序表的实现较为简单，源码路径为
### 动态线性表


# 
