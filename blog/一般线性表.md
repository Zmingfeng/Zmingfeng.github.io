---
title: 一般线性表
date: 2018-08-29 19:54:55
tags: 数据结构
categories: 数据结构
---

线性表是数据结构中最简单的逻辑结构，其特点为一对一，即**线性表中除表头和表位外的每个元素，都有且只有一个直接前驱和一个直接后继，而表头元素只有一个直接后继，没有直接前驱；表尾元素只有一个直接前驱，而无直接后继因此，表中各元素是由先后顺序的**。

注1：线性表中的各元素都属于同一数据类型，故而占用相同的存储空间，除此之外，线性表长度有限。

注2：本文对不同存储结构的算法实现都包括：线性表的创建、插入元素、删除元素、查找元素，在本篇中的查找算法使用的都是简单查找，其余查找算法将会由另外的一篇文章给出。

已经从逻辑结构上介绍了线性表的基本概念，也就是该结构中元素之间的相邻关系，接着就要讨论该如何实现该逻辑结构，这就引出了存储结构的概念。存储结构解决的是线性表在物理上如何存储的问题，线性表的存储结构决定了算法的实现方法，本文将要讨论的是线性表的顺序存储和链式存储。

## 顺序存储

### 基本概念

顺序存储又被称为顺序表，它利用一组地址连续的存储单元依次存储线性表中的数据元素，特点是**逻辑上相邻的数据元素在物理上也连续，所以顺序表中的元素可以通过首地址和元素序号进行随机访问，时间复杂度为`O(1)`，但是插入和删除操作都要移动大量元素**。

顺序表的存储结构可以用下图表示：
![数组指针](/images/arr_list.jpg)

### 静态顺序表

静态顺序表又可以被称为数组，数组的大小和空间在定义后就固定不变，这种内存分配方式被称为静态分配。

**静态顺序表的创建：**
```C
void InitList(SqList *L)
{
  L->length = 0;
  for(int i= 0;i < MAXSIZE;i++)
  {
    L->data[i] = (Elemtype)i;
    L->length++;
  }
  printf("length is %d\n",L->length);
}
```
**静态顺序表的插入：**
```C
bool ListInsert(SqList *L,int i,Elemtype e)
{
  if(i < 1 || i > L->length + 1) return false; //the scope of i needs to be suitable.
  if(L->length >= MAXSIZE) return false; //the length can't more than MAXSIZE.
  for(int j = L->length;j >= i;j--)
  {
    L->data[j] = L->data[j-1];
  }
  L->data[i-1] = e;
  L->length++;
  return true;
}
```
**静态顺序表的删除：**
```C
bool ListDelete(SqList *L,int i,Elemtype *e)
{
  if(i < 1 || i > L->length) return false; //the scope of i needs to be suitable.
  if(L->length <= 0) return false; //the length can't less than one.
  *e = L->data[i-1];
  for(int j = i;j < L->length;j++)
  {
    L->data[j-1] = L->data[j];
  }
  L->length--;
  return true;
}
```
**静态顺序表的查找：**
```C
//search the item appears in L for the first time.
int ListSearch(SqList *L,Elemtype e)
{
  for(int i = 0;i < L->length;i++)
  {
    if(L->data[i] == e) return (i+1);
  }
  return false;
}
```

静态顺序表的实现较为简单，源码路径为
### 动态线性表