---
title: 算法时间复杂度计算方法
date: 2018-08-25 19:34:56
tags: 数据结构
categories: 数据结构
---

每次在设计算法的时候，我们都要考虑该算法的时间复杂度，从而可以从同一个问题的不同算法中取得相对时间复杂度较低的算法，那么时间复杂度到底如何计算，这就是本文的重点。

## 循环体中的变量和循环条件有关

此类时间复杂度计算只需要通过假设语句的执行次数，根据判断条件即可求出。

例1：
```C
int i = 1;
while(i < n) i *= 2;
```
i 在循环体中参与计算，但是同样又是while判断的依据，`i *= 2`这条语句的执行次数就是该算法的渐近时间复杂度，设该语句执行了t次，那么就是i在执行过程中乘了t个2，所以i的上限是2^t，所以最终判断条件是 2^t <= n,即t < log2n,这是渐近时间复杂度T(n) = O(log2n)。

例2：
```C
int y = 5;
while((y+1) * (y+1) < n) y = y+1;
```
`y = y+1`最终会执行t次，所以y值上限为`y = t + 5`，此时有判断条件`(t+6)^2 < n`，所以有`t < n^(1/2) - 6`，渐近时间复杂度T(n) = O(n^(1/2))。

## 循环体中的变量和循环条件无关

此类时间复杂度计算一般采用数学归纳法或者递推法，但又因算法执行的策略不同而有所不同，分为递归和非递归。

### 递归算法

对于递归算法，一般采用递推法（迭代法）进行时间复杂度计算。

例3：
**给出一个递归方程，当`n = 1,T(n) = 1`，当`n > 1,T(n) = 2T(n/2) + n`，其中n为问题的规模，n为2的整数次幂；某算法所需时间由该方程给出，求该算法的时间复杂度阶别。**

可以知道该题直接给出了时间复杂度的递推公式，所以设`n = 2^k`，则有`T(2^k) = 2T(2^(k-1)) + 2^k = (2^2)T(2^(k-2)) + 2 *(2^k) = (2^k)T(1) + k *(2^k) = (k + 1) * (2^k)`，即`T(n) = (log2n + 1) * n`，渐近时间复杂度为O(nlog2n)。



### 非递归算法

非递归算法的时间复杂度计算较为简单，直接累计最深层语句的执行次数就行。

例4：
```C
for(i=0;i<n;i++)
  for(j=0;j<m;j++)
    a[i][j] = 0;
```

时间复杂度T(n) = O(n*m)

未完待续。。。